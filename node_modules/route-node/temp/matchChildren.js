"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var search_params_1 = require("search-params");
var getPath = function (path) { return path.split('?')[0]; };
var getSearch = function (path) { return path.split('?')[1] || ''; };
var matchChildren = function (nodes, pathSegment, currentMatch, options, consumedBefore) {
    if (options === void 0) { options = {}; }
    var strictQueryParams = options.strictQueryParams, strictTrailingSlash = options.strictTrailingSlash, strongMatching = options.strongMatching;
    var isRoot = nodes.length === 1 && nodes[0].name === '';
    var _loop_1 = function (child) {
        // Partially match path
        var match;
        var remainingPath = void 0;
        var segment = pathSegment;
        if (consumedBefore === '/' && child.path === '/') {
            // when we encounter repeating slashes we add the slash
            // back to the URL to make it de facto pathless
            segment = '/' + pathSegment;
        }
        if (!child.children.length) {
            match = child.parser.test(segment, options);
        }
        if (!match) {
            match = child.parser.partialTest(segment, {
                delimiter: strongMatching
            });
        }
        if (match) {
            // Remove consumed segment from path
            var consumedPath = child.parser.build(match, {
                ignoreSearch: true
            });
            if (!strictTrailingSlash && !child.children.length) {
                consumedPath = consumedPath.replace(/\/$/, '');
            }
            remainingPath = segment.replace(consumedPath, '');
            if (!strictTrailingSlash && !child.children.length) {
                remainingPath = remainingPath.replace(/^\/\?/, '?');
            }
            var querystring = search_params_1.omit(getSearch(segment.replace(consumedPath, '')), child.parser.queryParams).querystring;
            remainingPath =
                getPath(remainingPath) +
                    (querystring ? "?" + querystring : '');
            if (!strictTrailingSlash &&
                !isRoot &&
                remainingPath === '/' &&
                !/\/$/.test(consumedPath)) {
                remainingPath = '';
            }
            currentMatch.segments.push(child);
            Object.keys(match).forEach(function (param) { return (currentMatch.params[param] = match[param]); });
            if (!isRoot && !remainingPath.length) {
                return { value: currentMatch };
            }
            if (!isRoot &&
                !strictQueryParams &&
                remainingPath.indexOf('?') === 0) {
                // unmatched queryParams in non strict mode
                var remainingQueryParams_1 = search_params_1.parse(remainingPath.slice(1));
                Object.keys(remainingQueryParams_1).forEach(function (name) {
                    return (currentMatch.params[name] =
                        remainingQueryParams_1[name]);
                });
                return { value: currentMatch };
            }
            // Continue matching on non absolute children
            var children = child.getNonAbsoluteChildren();
            // If no children to match against but unmatched path left
            if (!children.length) {
                return { value: null };
            }
            return { value: matchChildren(children, remainingPath, currentMatch, options, consumedPath) };
        }
    };
    // for (child of node.children) {
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var child = nodes_1[_i];
        var state_1 = _loop_1(child);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    return null;
};
exports.default = matchChildren;
